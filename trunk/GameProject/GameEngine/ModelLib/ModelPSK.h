#ifndef MODEL_PSK_H
#define MODEL_PSK_H

#include <vector>
#include <EngineCore/Math/Quaternion.h>
#include <EngineCore/Math/Vector.h>

/*-----------------------------------------------------------------------------
	Data structures only used for importing PSA/PSK files.
----------------------------------------------------------------------------*/
struct FVector {
	FLOAT X,Y,Z;
};

class FColor
{
public:
	// Variables.
#if _MSC_VER
	// Win32 x86
	union { struct{ BYTE B,G,R,A; }; DWORD AlignmentDummy; };
#else
	// Linux x86, etc
	BYTE B GCC_ALIGN(4);
	BYTE G,R,A;
#endif
};

struct FVertInfluence 
{
	FLOAT Weight;
	WORD VertIndex;
	WORD BoneIndex;
	/*friend FArchive &operator<<( FArchive& Ar, FVertInfluence& F )
	{
		return Ar << F.Weight << F.VertIndex << F.BoneIndex;
	}*/
};

// A bone: an orientation, and a position, all relative to their parent.
struct VJointPos
{
	noQuat   	Orientation;  //
	FVector		Position;     //  needed or not ?

	FLOAT       Length;       //  For collision testing / debugging drawing...
	FLOAT       XSize;
	FLOAT       YSize;
	FLOAT       ZSize;

	/*friend FArchive &operator<<( FArchive& Ar, VJointPos& V )
	{
		return Ar << V.Orientation << V.Position;
	}*/
};

// Binary bone format to deal with raw animations as generated by various exporters.
struct FNamedBoneBinary
{
	char   Name[64];	// Bone's name
	DWORD      Flags;		// reserved
	INT        NumChildren; //
	INT		   ParentIndex;	// 0/NULL if this is the root bone.  
	VJointPos  BonePos;	    //
};

struct FMeshWedge
{
	WORD			iVertex;		// Vertex index.
	FLOAT			U,V;			// UVs.
	//friend FArchive &operator<<( FArchive& Ar, FMeshWedge& T )
	//{
	//	Ar << T.iVertex << T.U << T.V;
	//	return Ar;
	//}
};
//template <> struct TIsPODType<FMeshWedge> { enum { Value = true }; };

struct FMeshFace
{
	WORD		iWedge[3];			// Textured Vertex indices.
	WORD		MeshMaterialIndex;	// Source Material (= texture plus unique flags) index.

	//friend FArchive &operator<<( FArchive& Ar, FMeshFace& F )
	//{
	//	Ar << F.iWedge[0] << F.iWedge[1] << F.iWedge[2];
	//	Ar << F.MeshMaterialIndex;
	//	return Ar;
	//}
};
//template <> struct TIsPODType<FMeshFace> { enum { Value = true }; };

// Reference-skeleton bone, the package-serializable version.
struct FMeshBone
{
	hkString	Name;		  // Bone's name.
	DWORD		Flags;        // reserved
	VJointPos	BonePos;      // reference position
	INT         ParentIndex;  // 0/NULL if this is the root bone.  
	INT 		NumChildren;  // children  // only needed in animation ?
	INT         Depth;        // Number of steps to root in the skeletal hierarcy; root=0.

	// DEBUG rendering
	FColor		BoneColor;		// Color to use when drawing bone on screen.

	BOOL operator==( const FMeshBone& B ) const
	{
		return( Name == B.Name );
	}

	/*friend FArchive &operator<<( FArchive& Ar, FMeshBone& F)
	{
		Ar << F.Name << F.Flags << F.BonePos << F.NumChildren << F.ParentIndex;

		if( Ar.IsLoading() && Ar.Ver() < VER_SKELMESH_DRAWSKELTREEMANAGER )
		{
			F.BoneColor = FColor(255, 255, 255, 255);
		}
		else
		{
			Ar << F.BoneColor;
		}

		return Ar;
	}*/
};

// File header structure. 
struct VChunkHeader
{
	char	ChunkID[20];  // string ID of up to 19 chars (usually zero-terminated)
	INT			TypeFlag;     // Flags/reserved
    INT         DataSize;     // size per struct following;
	INT         DataCount;    // number of structs/
};


// Raw data material.
struct VMaterial
{
	char            MaterialName[64];
	INT					TextureIndex;  // texture index ('multiskin index')
	DWORD				PolyFlags;     // ALL poly's with THIS material will have this flag.
	INT				    AuxMaterial;   // reserved: index into another material, eg. detailtexture/shininess/whatever.
	DWORD				AuxFlags;      // reserved: auxiliary flags 
	INT					LodBias;       // material-specific lod bias
	INT					LodStyle;      // material-specific lod style
};


// Raw data bone.
struct VBone
{
	char    Name[64];     //
	DWORD		Flags;        // reserved / 0x02 = bone where skin is to be attached...	
	INT 		NumChildren;  // children  // only needed in animation ?
	INT         ParentIndex;  // 0/NULL if this is the root bone.  
	VJointPos	BonePos;      // reference position
};

// Bone influence blending
struct VBoneInfIndex // ,, ,, contains Index, number of influences per bone (+ N detail level sizers! ..)
{
	WORD WeightIndex;
	WORD Number;	// how many to process 
	WORD DetailA;  // how many to process if we're up to 2 max influences
	WORD DetailB;  // how many to process if we're up to full 3 max influences 

	/*friend FArchive &operator<<( FArchive& Ar, VBoneInfIndex& V )
	{
		return Ar << V.WeightIndex << V.Number << V.DetailA << V.DetailB;
	}*/
};

struct VBoneInfluence // Weight and bone number
{
	WORD BoneWeight; 
	WORD BoneIndex; 
	/*friend FArchive &operator<<( FArchive& Ar, VBoneInfluence& V )
	{
		return Ar << V.BoneWeight << V.BoneIndex;
	}*/
};

// 3d vertex point index into a VBoneBlend array.
struct VWeightIndex
{
	hkArray<WORD> PointIndices;
	INT  WeightBase;
	/*friend FArchive &operator<<( FArchive& Ar, VWeightIndex& V )
	{
		return Ar << V.PointIndices << V.WeightBase;
	}*/
};

// Raw data bone influence.
struct VRawBoneInfluence // just weight, vertex, and Bone, sorted later....
{
	FLOAT Weight;
	INT   VertexIndex;
	INT   BoneIndex;
};

// Vertex with texturing info, akin to Hoppe's 'Wedge' concept - import only.
struct VVertex
{
	WORD	VertexIndex; // Index to a vertex.
	FLOAT   U,V;         // Scaled to BYTES, rather...-> Done in digestion phase, on-disk size doesn't matter here.
	BYTE    MatIndex;    // At runtime, this one will be implied by the face that's pointing to us.
	BYTE    Reserved;    // Top secret.
};

// Points: regular tVector4s (for now..)
struct VPoint
{	
	FVector	Point; // Change into packed integer later IF necessary, for 3x size reduction...
};


// Textured triangle.
struct VTriangle
{
	WORD   WedgeIndex[3];	 // Point to three vertices in the vertex list.
	BYTE    MatIndex;	     // Materials can be anything.
	BYTE    AuxMatIndex;     // Second material from exporter (unused)
	DWORD   SmoothingGroups; // 32-bit flag for smoothing groups.

	/*friend FArchive &operator<<( FArchive& Ar, VTriangle& V )
	{
		Ar << V.WedgeIndex[0] << V.WedgeIndex[1] << V.WedgeIndex[2];
		Ar << V.MatIndex << V.AuxMatIndex;
		Ar << V.SmoothingGroups;
		return Ar;
	}*/

	VTriangle& operator=( const VTriangle& Other)
	{
		this->AuxMatIndex = Other.AuxMatIndex;
		this->MatIndex        =  Other.MatIndex;
		this->SmoothingGroups =  Other.SmoothingGroups;
		this->WedgeIndex[0]   =  Other.WedgeIndex[0];
		this->WedgeIndex[1]   =  Other.WedgeIndex[1];
		this->WedgeIndex[2]   =  Other.WedgeIndex[2];
		return *this;
	}
};

//
// Bundle of raw data - from our 3DSMax plugin output.
//
struct FSkelImport 
{
	hkArray <VMaterial>			Materials;		// Materials
	hkArray <FVector>			Points;			// 3D Points
	hkArray <VVertex>			Wedges;			// Wedges
	hkArray <VTriangle>			Faces;			// Faces
	hkArray <VBone>				RefBonesBinary;	// reference skeleton
	hkArray <VRawBoneInfluence>	Influences;		
};

// An animation key.
struct VQuatAnimKey
{
	FVector	Position;           // relative to parent.
	noQuat	Orientation;        // relative to parent.
	FLOAT	Time;				// The duration until the next key (end key wraps to first...)

	/*friend FArchive &operator<<( FArchive& Ar, VQuatAnimKey& V )
	{
		return Ar << V.Position << V.Orientation << V.Time;
	}*/
};

// Binary animation info format - used to organize raw animation keys into FAnimSeqs on rebuild
// Similar to MotionChunkDigestInfo..
struct AnimInfoBinary
{
	char	Name[64];			// Animation's name
	char	Group[64];			// Animation's group name	

	INT			TotalBones;			// TotalBones * NumRawFrames is number of animation keys to digest.

	INT			RootInclude;		// 0 none 1 included 		
	INT			KeyCompressionStyle;// Reserved: variants in tradeoffs for compression.
	INT			KeyQuotum;			// Max key quotum for compression	
	FLOAT		KeyReduction;		// desired 
	FLOAT		TrackTime;			// explicit - can be overridden by the animation rate
	FLOAT		AnimRate;			// frames per second.
	INT			StartBone;			// - Reserved: for partial animations.
	INT			FirstRawFrame;		//
	INT			NumRawFrames;		// NumRawFrames and AnimRate dictate tracktime...
};


/**
* Container and importer for skeletal mesh (psk file) data
**/
class FSkeletalMeshBinaryImport
{
public:
	hkArray <VMaterial>			Materials;		// Materials
	hkArray <FVector>			Points;			// 3D Points
	hkArray <VVertex>			Wedges;			// Wedges
	hkArray <VTriangle>			Faces;			// Faces
	hkArray <VBone>				RefBonesBinary;	// Reference Skeleton
	hkArray <VRawBoneInfluence>	Influences;		// Influences

	/**
	* Parse skeletal mesh (psk file) from buffer into raw import data
	* 
	* @param BufferReadPtr	- start of data to be read
	* @param BufferEnd - end of data to be read
	* @param bShowSummary - if TRUE then print a summary of what was read to file
	*/
	void ImportFromFile( BYTE* BufferReadPtr, const BYTE* BufferEnd, BOOL bShowSummary = TRUE );

	/**
	* Copy mesh data for importing a single LOD
	*
	* @param LODPoints - vertex data.
	* @param LODWedges - wedge information to static LOD level.
	* @param LODFaces - triangle/ face data to static LOD level.
	* @param LODInfluences - weights/ influences to static LOD level.
	*/ 
	void CopyLODImportData( 
		hkArray<FVector>& LODPoints, 
		hkArray<FMeshWedge>& LODWedges,
		hkArray<FMeshFace>& LODFaces,	
		hkArray<FVertInfluence>& LODInfluences );

	static hkString FixupBoneName( char *AnisBoneName );
};

/** 
* Optional data passed in when importing a skeletal mesh LDO
*/
class FSkelMeshOptionalImportData
{
public:
	FSkelMeshOptionalImportData() {}

	/** extra data used for importing extra weight/bone influences */
	FSkeletalMeshBinaryImport RawMeshInfluencesData;
};

class FArchiveFileReaderWindows 
{
public:
	FArchiveFileReaderWindows( HANDLE InHandle, INT InStatsHandle, const TCHAR* InFilename, INT InSize );
	~FArchiveFileReaderWindows();

	virtual void Seek( INT InPos );
	virtual INT Tell();
	virtual INT TotalSize();
	virtual UINT Close();
	virtual void Serialize( void* V, INT Length );

protected:
	UINT InternalPrecache( INT PrecacheOffset, INT PrecacheSize );

	HANDLE          Handle;
	/** Handle for stats tracking */
	INT				StatsHandle;
	/** Filename for debugging purposes. */
	const TCHAR*	Filename;	
	INT             Size;
	INT             Pos;
	INT             BufferBase;
	INT             BufferCount;
	BYTE            Buffer[1024];
	UINT			ArIsError;
};

extern FArchiveFileReaderWindows* CreateFile(const TCHAR* Filename);


class PSABinaryImport {
public:

	bool ImportFromFile(const TCHAR* Filename);
	std::vector<class noaAnimation*> m_animSeqs;
};



#endif